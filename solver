#!/bin/bash

declare -a blacklist
declare -a report
pkgm=''
distro=''
ver='0.1'
LANGUAGE_PREV=$LANGUAGE
LANGUAGE=en_US.UTF-8 
LANG=$LANG
LANG=en_US.UTF-8


#
### Solvers
#

touchpad_force_reload () 
{
	drivers_str=$(lsmod | awk '{print $1 " "}' |  egrep '.*touch.*|.*mouse.*')
	set -f; IFS=$'\n'
	set -- $drivers_str
	set +f; unset IFS

	for driver in $@; do
		msg "Recargando driver $driver,..."
		sudo modprobe -r $driver && sleep 1 && sudo modprobe $driver
	done
}

# --OK
touchpad () {

	# Parsear xinput buscando "Touchpad"
	[[ ! -z `which xinput 2>/dev/null` && -z $(xinput | grep -i touchpad) ]] && msg "Touchad no detectado - driver?"

	shopt -s nocasematch
	case $XDG_CURRENT_DESKTOP in
	     *gnome*) # probar
				enabled=$(gsettings get org.gnome.desktop.peripherals.touchpad send-events)

				if [[ $enabled == "false" ]]; then
					msg "Habilitando Touchpad (..)"
					gsettings set org.gnome.desktop.peripherals.touchpad send-events enabled
				fi
	          	;;
	     *cinnamon*)      
				enabled=$(gsettings get org.cinnamon.settings-daemon.peripherals.touchpad touchpad-enabled)

				if [[ $enabled == "false" ]]; then
					msg "Habilitando Touchpad (..)"
					gsettings set org.cinnamon.settings-daemon.peripherals.touchpad touchpad-enabled true
				fi
	          	;;

	     *)  # otros escritorios

			if [[ ! -z `which xinput 2>/dev/null` ]]; then
				local id=$(xinput list | egrep -i 'Touchpad|Synaptics' | awk '{ print $6 }' | cut -c4-6)
				local enabled=$(xinput list-props $id | grep Device\ Enabled | awk '{print $4}')

				if [[ $enabled -eq 0 ]]; then
					msg "Intentando habilitar Touchpad (..)"
					xinput enable "$id"
					xinput set-prop "$id" "Device Enabled" 1
				fi

				# Vuelvo a chequear ...
				enabled=$(xinput list-props $id | grep Device\ Enabled | awk '{print $4}')
				if [[ $enabled -eq 0 ]]; then
					msg "Touchpad deshabilitado - sin solucionar"
				fi	
			fi

			if [[ ! -z `which TouchpadOff 2>/dev/null` ]]; then
				synclient TouchpadOff=0
			fi	
    		;;      	
	esac
	shopt -u nocasematch

	[[ $force -eq 1 ]] && touchpad_force_reload

	# Parsear la linea GRUB_CMDLINE_LINUX_DEFAULT de /etc/default/grub en búsqueda de acpi=off por ejemplo
	(grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub | egrep '(acpi=off|acpi_os=!)') >/dev/null 2>&1
	[[ $? -eq 0 ]] && msg "ACPI fue deshabilitado: $(grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub)"
}

# -- OK
bluetooth () {
	# bloqueado ? desbloquear 
	rf bluetooth
}

# --OK
sound () {
	get_pci_driver 'audio'

	set -f; IFS=',' 
	set -- $drivers
	set +f; unset IFS
	driver_list=($@)

	blacklist_check

	# muted?
	muted=$(pacmd list-sinks | awk '/muted/ { print $2 }')
	
	if [[ $muted == 'yes' ]]; then
		msg "Audio: hay un dispositivo 'silenciado', solucionando (..)"
		amixer -c 0 set Master playback 100% unmute >/dev/null 2>&1
		sleep 1
		amixer sset Master unmute >/dev/null 2>&1
		amixer sset Speaker unmute >/dev/null 2>&1
		amixer sset Headphone unmute >/dev/null 2>&1

		muted=$(pacmd list-sinks | awk '/muted/ { print $2 }')
		[[ $muted == 'no' ]] && msg "Audio: dispositivo de audio pudo ser 'unmuted' -OK"
	else
		msg "No hay dispositivo de audio 'muted' -OK" "v"
	fi	

	# aplicar algo de esto?
	# https://askubuntu.com/questions/1029502/no-audio-on-ubuntu-18-04
	# https://help.ubuntu.com/community/SoundTroubleshootingProcedure
	# https://zillowtech.com/ubuntu-no-sound.html
}

# -- OK
performance () {
	local mem_ava=$(cat /proc/meminfo | grep MemAvailable | awk '{print $2}')	

	local free_space_root=$(df -h | awk '
		$6=="/" {
			print $4
		}
	')

	local free_space_root_h=$free_space_root

	free_space_root=${free_space_root/K/000}
	free_space_root=${free_space_root/M/000000}
	free_space_root=${free_space_root/G/000000000}
	free_space_root=${free_space_root/T/000000000000}

	# menos de 4Gb libres en /
	if [[ $free_space_root -le 4000000000 ]]; then 
		free_space_root_h=${free_space_root_h/}
		msg "Poco espacio ($free_space_root_h) en partición root"
	else
		msg "$free_space_root_h en partición root" "v"
	fi	
	
	# Menos de 150Kb libres de RAM
	if [[ $mem_ava -le 150000 ]]; then
		msg "Memoria disponible insuficiente ($mem_ava kb)"
	else
		msg "$mem_ava kb de RAM disponible" "v"
	fi	
}


# Detectar errores de Ethernet
ethernet () 
{
	get_pci_driver 'ethernet'

	set -f; IFS=',' 
	set -- $drivers
	set +f; unset IFS
	driver_list=($@)

	blacklist_check

	interfaces=$(ls /sys/class/net | grep '^e.*')

	local downs=0
	for interface in $interfaces; do
		if [[ -z $(sudo ip address show $interface | grep "UP>") ]]; then
			msg "Interfaz $interface está apagada, encendiendo (..)"
			(( downs++ ))
			sudo ip link set "$interface" up 2>/dev/null
			[[ $? -ne 0 ]] && msg "Interfaz $interface no se pudo levantar"
		fi
	done	
	
	# Esto también va acá? | LEO: Si, es lo mismo que sea para ethernet que wifi
	if [[ $downs -gt 0 ]]; then
		if [[ ! -z $(systemctl list-unit-files | grep network-manager | grep enabled) ]]; then 
			msg "Re-iniciando NetworkManager (..)"
			sudo service network-manager restart
			sleep 10
		fi	
	fi	

	#si tiene conexion al medio (cable) hacer:
	for interface in $interfaces; do
		errora=0
		if [[ $(sudo ip address show $interface | grep "LOWER_UP>") ]]; then
			# Tiene IP
			[[ -z $(ip address show $interface | grep "inet " | awk '{print $2}') ]] && msg "No se encontro dirección IP para la interfaz: $interface" && (( errora++ ))

			# IP/CIDR
			maskara=$(ip address show $interface | grep "inet " | awk '{print $2}') # Obtiene IP/CIDR
			maskara=${maskara:(-2)} # Corta el string, dejando los dós digitos de la derecha
			[[ maskara -eq 0 ]] && { msg "No se encontro mascara de red para la interfaz: $interface" && (( errora++ )); }

			# Gateway
			[[ -z $(ip route show |grep default | awk '{print $3}') ]] && msg "No se encontro puerta de enlace para la interfaz: $interface"
			gateway=$(ip route show |grep default | awk '{print $3}' | cut -d$'\n' -f1)

			# DNS
			dns=$(cat /etc/resolv.conf | grep nameserver -m 1 | awk '{print $2}')
			[[ -z $dns ]] && msg "No se encontraron servidores DNS en '/etc/resolv.conf' "

			# si errora es igual a 0 hace ping contra el router
			if [[ $errora -eq 0 ]]; then
				msg "Probando conexion de $interface, espere..."
				
				# Ping Gateway
				myping=$(ping -c3 $gateway | grep "packets transmitted" | awk '{print $4}')
				[[ myping -eq 0 ]] && msg "no hay conexion con el router" || msg "Conexion exitosa con el router -OK"
				
				# Ping DNS
				myping=$(ping -c5 $dns | grep "packets transmitted" | awk '{print $4}')
				[[ myping -eq 0 ]] && msg "No hay conexion con el servidor DNS" || msg "Conexion exitosa con el servidor DNS -OK"
			fi

		else
			msg "Cable desconectado en interfaz: $interface"
		fi
	done
}

# Detectar errores de wifi
wireless () 
{
	# PCI
	get_pci_driver 'wireless'

	set -f; IFS=',' 
	set -- $drivers
	set +f; unset IFS
	driver_list=($@)

	blacklist_check

	# USB
	get_usb_driver "wireless adapter"

	# No hay driver en uso?
	if [[ ! -z "$hardware" ]]; then
		if [[ -z "$driver_en_uso" ]]; then
			msg "Wireless USB: no hay driver para $hardware"
		else
			msg "Driver '$driver_en_uso' en uso para '$hardware' -OK" "v"
		fi
	else
		msg "Hardware para adaptador USB no detectado" "v"
	fi

	# bloqueado ? desbloquear
	rf wlan

	# verifico interfaces
	local interfaces=$(cat /proc/net/dev | grep -o w[a-z0-9]*: | cut -d':' -f1)
	local interfaces_up=$(cat /proc/net/wireless | awk '/:/  {print $1}' | cut -d':' -f1)

	[[ "${#interfaces[@]}" -eq 0 ]] && msg "No se encontraron interfaces de red wireless"

	local downs=0
	local fails=0
	for interface in $interfaces; do
		in_array $interface interfaces_up
		if [[ $? -ne 0 ]]; then
			msg "Interfaz $interface está apagada, encendiendo (..)"
			(( downs++ ))
			sudo ip link set "$interface" up 2>/dev/null
			[[ $? -ne 0 ]] && { ((fails++)) && msg "Interfaz $interface no se pudo levantar"; }
		fi
	done	

	[[ "${#interfaces[@]}" -eq $fails ]] && return

	if [[ $downs -gt 0 ]]; then
		if [[ ! -z $(systemctl list-unit-files | grep network-manager | grep enable ) ]]; then
			msg "Re-iniciando NetworkManager (..)"
			sudo service network-manager restart
			sleep 10
		fi	
	fi

	#si tiene conexion al medio (aire) hacer:
	dns_tested=false
	for interface in $interfaces; do
		errora=0
		if [[ $(sudo ip address show $interface | grep "LOWER_UP>") ]]; then
			# Tiene IP
			[[ -z $(ip address show $interface | grep "inet " | awk '{print $2}') ]] && msg "No se encontro dirección IP para la interfaz: $interface" && (( errora++ ))

			# IP/CIDR
			maskara=$(ip address show $interface | grep "inet " | awk '{print $2}') # Obtiene IP/CIDR
			maskara=${maskara:(-2)} # Corta el string, dejando los dós digitos de la derecha
			[[ maskara -eq 0 ]] && { msg "No se encontro mascara de red para la interfaz: $interface" && (( errora++ )); }

			# Gateway
			[[ -z $(ip route show |grep default | awk '{print $3}') ]] && msg "No se encontro puerta de enlace para la interfaz: $interface"
			gateway=$(ip route show |grep default | awk '{print $3}' | cut -d$'\n' -f1) 

			# DNS
			dns=$(cat /etc/resolv.conf | grep nameserver -m 1 | awk '{print $2}')
			[[ -z $dns ]] && msg "No se encontraron servidores DNS en '/etc/resolv.conf' "

			# si errora es igual a 0 hace ping contra router y DNS
			if [[ $errora -eq 0 ]]; then
				msg "Probando conexion de $interface, espere..."

				# Ping Gateway
				myping=$(ping -c3 $gateway | grep "packets transmitted" | awk '{print $4}')
				[[ $myping -eq 0 ]] && msg "No hay conexion con el router" || msg "Conexion exitosa con el router -OK"
				
				# Ping DNS
				if [[ $dns_tested == "false" ]]; then	# testeo el DNS Server una sola vez
					myping=$(ping -c5 $dns | grep "packets transmitted" | awk '{print $4}')
					[[ $myping -eq 0 ]] && msg "No hay conexion con el servidor DNS" || msg "Conexion exitosa con el servidor DNS -OK"
					dns_tested=true
				fi	
			fi

		else
			msg "Sin conexión WiFi en: $interface"
		fi
	done
}


video () 
{
	msg 'No implementado (aún)'
	return

	######################

	get_pci_driver 'vga|3d|2d|display'

	set -f; IFS=',' 
	set -- $drivers
	set +f; unset IFS
	driver_list=($@)

	blacklist_check
}

#
## Utils
#

get_pci_driver ()
{
	local search="$1"

	local addr=$(lspci | grep -i "$search" | grep -o '[0-9]\{2\}:[0-9a-f]\{2\}.[0-9a-f]')
	[[ -z $addr ]] && return
	local reg=$(lspci -vs "$addr")

	hardware=$(echo "$reg" | grep -i 'Subsystem' | cut -d':' -f2 | cut -c2-)
	drivers=$(echo "$reg"  | grep -i 'Kernel modules:' | cut -d: -f2 | cut -c2-)
	driver_en_uso=$(echo "$reg" | grep 'in use:' | cut -d: -f2 | cut -c2-)
}

get_usb_driver ()
{
	local search="$1"

	local id=$((lsusb | grep -i "$search" 2>/dev/null) | grep -o '[0-9a-f]\{4\}:[0-9a-f]\{4\}')
	local reg=$(sudo lsusb -vd "$id" 2>/dev/null)    
	local id_vendor=$(echo "$reg" | grep idVendor | awk '{print $2}' | cut -dx -f2)
	local id_product=$(echo "$reg" | grep idProduct | awk '{print $2}' | cut -dx -f2)

	hardware=$(echo "$reg" | grep iProduct | awk '{print $3}')
	driver_en_uso=$(usb-devices | grep -A5 "Vendor=$id_vendor ProdID=$id_product" | grep -o Driver=[a-z0-9\-]* | cut -d= -f2)
}

rf () {
	# bluetooth|wlan
	type=$1

	[[ $type == "wlan" ]] && pattern='phy'
	[[ $type == "bluetooth" ]] && pattern='hci'

	declare -a soft_lock
	declare -a hard_lock

	IFS=$'\n'; 
	set -- $(rfkill list); 

	argv=($@)
	for ((i=0;i<$#;i++)); do
		if [[ "${argv[i]}" =~ "$pattern" ]]; then 
			device=$(echo "${argv[i]}" | egrep -o "$pattern[0-9]*")
			id=$(echo "${argv[i]}" | egrep -o '^[0-9]*')
			has_soft_lock=$(echo "${argv[i+1]}" | grep -o 'yes')
			has_hard_lock=$(echo "${argv[i+2]}" | grep -o 'yes')

			[[ ! -z $has_soft_lock ]] && soft_lock=("${soft_lock[@]}" "$id")	
			[[ ! -z $has_hard_lock ]] && hard_lock=("${hard_lock[@]}" "$id")

			if [[ ! -z $has_soft_lock  ]]; then
				if [[ -z $has_hard_lock ]]; then
					msg "Un dispositivo $type (id=$id) bloqueado por soft, desbloqueando (..)"
					rfkill unblock $id 2>/dev/null	
					sleep 1	
					if [[ ! -z $(rfkill list | grep -A 2 "$device" | grep -i 'Soft blocked: no') ]]; then 
						msg "Dispositivo $type desbloqueado -OK"
					else
						msg "Dispositivo $type no pudo ser desbloqueado"
					fi	
				else
					msg "Un dispositivo $type (id=$id) bloqueado por hard"
				fi	
			fi
		fi
		i=$i+2
	done	

	[[ "${soft_lock[@]}" -eq 0 ]] && [[ "${hard_lock[@]}" -eq 0 ]] && msg "No hay dispositivos $type bloqueados" "v"

}

#
# Busca un elemento en un arreglo
#
# @param string elemento_a_buscar	
# @param array 
# @return integer 0/1 según sea éxito o fracaso
#
in_array () {
	[[ $# -lt 2 ]] && return 1

	local elem=$1
	local arr_name=$2
	local _arr
	local x

	str='_arr="${'
	str+=$arr_name
	str+='[@]}"'

	eval $str

	for x in $_arr; do
		[ "${x}" == "$elem" ] && return 0
	done

	return 1
}

#
# Empuja un elemento a un array
#
# @param string elemento
# @param string nombre_array
#
push () {
	(( $# != 2 )) && return 1

	local arr_name=$2
	local str

	# array=("${array[@]}" "$2")
	str=$arr_name 
	str+='=("${'
	str+=$arr_name
	str+='[@]}" "$1")'

	eval $str
}

#
# Hace un 'split' de un string generando un array (simil explode de php)
#
# @param string string_to_explode
# @param string separator
# @param array 	
#
explode () {
	(( $# != 3 )) && return 1

	local strvar=$1
	local sep=$2
	local arrname=$3

	set -f; IFS="$sep" 
	eval "set -- ${!strvar}"
	set +f; unset IFS

	str=$arrname
	str+='=($@)'
	eval $str
}

msg () {
	if [[ "$2" != "v" ]] || [[ "$2" == "v" && $verbose -eq 1 ]]; then
		push "$1" report
 		echo "$1"
	fi
}

# Sistema de paquetes utilizado, distribución, etc
describe () {	
	if [[ ! -z $(which apt 2>/dev/null) ]]; then
		pkgm='apt'
		else 
			if [[ ! -z $(which dnf 2>/dev/null) ]]; then
				pkgm='dnf'	
			else
				if [[ ! -z $(which pacman 2>/dev/null) ]]; then
					pkgm='pacman'
				else
					if [[ ! -z $(which emerge 2>/dev/null) ]]; then
						pkgm='emerge'	
					fi	
				fi	
			fi	
	fi 	

	distro=`((cat /etc/*-release 2>/dev/null)| egrep '^ID=' | cut -c4-)`
}

# Drivers en lista negra
blacklist () {
	blacklist=$(cat /etc/modprobe.d/*blacklist* 2>/dev/null | egrep '^blacklist ' | cut -d' ' -f2)
}

blacklist_check ()
{
	if [[ -z $drivers ]]; then
		msg "No hay drivers para $hardware"
	else
		msg "Drivers '${drivers[@]}' para '$hardware'" "v"
	fi 

	# No hay driver en uso?
	if [[ -z "$driver_en_uso" ]]; then
		msg "No hay driver activo"

		# Verifico que ningún driver esté blacklisted
		for driver in "${driver_list[@]}"; do
			in_array "$driver" blacklist
			[[ $? -eq 0 ]] && { blacklisted=1; msg "Driver $driver está en blacklist"; }
		done	
		[[ $blacklisted -eq 0 ]] && msg "No hay drivers en blacklist -OK" "v"
	else 
		msg "Driver '$driver_en_uso' en uso para '$hardware' -OK" "v"		
	fi
}


key () {
	echo -e "\nPresione Enter para continuar..."
	read tecla
}

# MENU
menu () {
	while :
	do
		clear
		echo " Escoja una opción "
		echo "==================="
		echo "1. Verificar problemas de rendimiento"
		echo "2. Verificar video"
		echo "3. Verificar touchpad"
		echo "4. Problemas con ethernet"
		echo "5. Problemas con WiFi"
		echo "6. Problemas con bluetooth"
		echo "7. Problemas de sonido"
		echo "8. Salir del programa"
		echo -en "\nSeleccione una opción [1 - 8] "
		read opcion
		echo
			case $opcion in
			1) 	performance
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			2) 	video
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;	
			3) 	touchpad
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			4) 	sudo true; ethernet
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			5) 	sudo true; wireless
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			6)	bluetooth
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			7)	sound
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			8) 	exit 0
				key;;
			*) 	echo "'$opcion' es una opción invalida."
				key;;
			esac
		unset report[@] # Reinicia variable
	done
}

options () 
{
	help=$(cat <<-TEXT

	Usage:
	 $(basename $0) [-v] [-f] <options>

	Display or solve hardware configuration issues

	Options:
	 -v, --verbose                  show detailed information
	 -f, --force                    force to solve when it's possible

	 -i, --interactive              interactive mode (menu)
	 -a, --all                      run all tests  
	 -b, --bluetooth                bluetooth checking
	 -d, --display                  video cards
	 -t, --touchpad                 touchpad checking
	 -w, --wireless                 wifi tests
	 -e, --ethernet                 ethernet tests
	 -p, --performance              check why computer can be running slow
	 -s, --sound                    sound tests 

	 -h, --help                     display this help
	 -V, --version                  display version

TEXT
)

	verbose=

	case "$1" in
	-v|--verbose)
	    verbose=1
	    shift 1
	    ;;
	esac

	force=

	case "$1" in
	-f|--force)
	    force=1
	    shift 1
	    ;;
	esac

	sel=$1

	case $sel in
	-V|--version)
	  	echo "$(basename $0) version $ver"
	  	return
		;;
	-h|--help)
		echo -e "$help"
		return
		;;
	-i|--interactive)
		menu
		;;  
	-a|-all)
		sudo true
		echo -e '\n[Performance]'
		unset report[@]
		performance
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Sound]'
		unset report[@]
		sound
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Bluetooth]'
		unset report[@]
		bluetooth
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Touchpad]'
		unset report[@]
		touchpad
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Ethernet]'
		unset report[@]
		ethernet
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Wireless]'
		unset report[@]
		wireless
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-p|--performance)
		performance
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;	
	-d|--display)
		video 
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;	
	-s|--sound)
		sound
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-b|--bluetooth)
		bluetooth
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-t|--touchpad)
		touchpad
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;		
	-e|--ethernet)
		sudo true
		ethernet
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-w|wireless)
		sudo true
		wireless
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;		
	*)
		
		if [[ $# -eq 0 ]]; then
			echo -e "$help"
		else
			echo -e "$(basename $0): unrecognized option '$sel'\nTry '$(basename $0) --help' for more information";
		fi 
		return
		;;
	esac
}

describe ; [[ -z $pkgm ]] && msg "Package management desconocido"
blacklist


options $@ 