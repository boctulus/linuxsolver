#!/bin/bash

declare -a blacklist
declare -a report
pkgm=''
distro=''
ver='0.1'
LANGUAGE_PREV=$LANGUAGE
LANGUAGE=en_US.UTF-8 
LANG=$LANG
LANG=en_US.UTF-8


#
### Solvers
#

# --OK
touchpad () {

	# Parsear xinput buscando "Touchpad"
	[[ ! -z `which xinput 2>/dev/null` && -z $(xinput | grep -i touchpad) ]] && push "Touchad no detectado"

	shopt -s nocasematch
	case $XDG_CURRENT_DESKTOP in
	     *gnome*) # probar
				enabled=$(gsettings get org.gnome.desktop.peripherals.touchpad touchpad-enabled)

				if [[ $enabled == "false" ]]; then
					push "Habilitando Touchpad (..)"
					gsettings set org.gnome.desktop.peripherals.touchpad send-events enabled
					sudo modprobe -r psmouse; sleep 1; sudo modprobe psmouse
				fi
	          	;;
	     *cinnamon*)      
				enabled=$(gsettings get org.cinnamon.settings-daemon.peripherals.touchpad touchpad-enabled)

				if [[ $enabled == "false" ]]; then
					push "Habilitando Touchpad (..)"
					gsettings set org.cinnamon.settings-daemon.peripherals.touchpad touchpad-enabled true
					sudo modprobe -r psmouse; sleep 1; sudo modprobe psmouse
				fi
	          	;;

	    *)

			if [[ ! -z `which xinput 2>/dev/null` ]]; then
				local id=$(xinput list | egrep -i 'Touchpad|Synaptics' | awk '{ print $6 }' | cut -c4-6)
				local enabled=$(xinput list-props $id | grep Device\ Enabled | awk '{print $4}')

				if [[ $enabled -eq 0 ]]; then
					push "Intentando habilitar Touchpad (..)"
					xinput enable "$id"
					xinput set-prop "$id" "Device Enabled" 1
					sudo modprobe -r psmouse; sleep 1; sudo modprobe psmouse
				fi

				# Vuelvo a chequear ...
				enabled=$(xinput list-props $id | grep Device\ Enabled | awk '{print $4}')
				if [[ $enabled -eq 0 ]]; then
					push "Touchpad deshabilitado - sin solucionar"
				fi	
			fi

			(test $pkgm == 'apt') && (apt list --installed  | grep xserver-xorg-input-synaptics) >/dev/null 2>&1
			if [[ $? -eq 0 ]]; then
				synclient TouchpadOff=0
			fi	
    		;;      	
	esac
	shopt -u nocasematch

	# Parsear la linea GRUB_CMDLINE_LINUX_DEFAULT de /etc/default/grub en búsqueda de acpi=off por ejemplo
	(grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub | egrep '(acpi=off|acpi_os=!)') >/dev/null 2>&1
	[[ $? -eq 0 ]] && push "ACPI fue deshabilitado: $(grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub)"
}


rf () {
	# bluetooth|wlan|id
	type=$1

	local soft_locked=$(rfkill -r | grep $type | awk '{ print $4 }')
	local hard_locked=$(rfkill -r | grep $type | awk '{ print $5 }')

	if [[ ! "$soft_locked" =~ "unblocked" ]]; then
		push "Hay un $type bloqueado por soft, desbloqueando (..)"
		rfkill unblock $type 2>/dev/null

		soft_locked=$(rfkill -r | grep $type | awk '{ print $4 }')
		if [[ ! "$soft_locked" =~ "unblocked" ]]; then
			push "Algún dispositivo $type bloqueado por soft que no pudo ser desbloqueado"		
		else	
			push "Dispositivos $type desbloqueados -OK"
			
		fi	
	fi	

	[[ ! "$hard_locked" =~ "unblocked" ]] && push "Hay un $type bloqueado por hard"
}


# -- OK
bluetooth () {
	# bloqueado ? desbloquear 
	rf bluetooth
}

# --OK
sound () {
	local hardware=$(lspci -v | grep -i -A7 audio  | grep -i 'Subsystem' | cut -d':' -f2 | cut -c2- )
	local driver_en_uso=$(lspci -v | grep -i -A7 audio  | grep 'Kernel driver in use' | cut -d':' -f2  | cut -c2-)
	local drivers=$(lspci -v | grep -i -A7 audio  | grep 'Kernel modules' | cut -d':' -f2  | cut -c2-)

	# No hay driver en uso?
	if [[ -z "$driver_en_uso" ]]; then
		push "Audio: no hay driver activo (drivers disponibles: $drivers, device: $hardware)"

		# Verifico que ningún driver esté blacklisted
		for driver in "${drivers[@]}"; do
			in_array "$driver" "${blacklist[@]}"
			[[ $? -eq 0 ]] && push "Audio: $driver está en blacklist"
		done	
	else
		push "Driver '$driver_en_uso' para '$hardware' -OK" "v"
	fi

	# muted?
	muted=$(pacmd list-sinks | awk '/muted/ { print $2 }')
	
	if [[ $muted == 'yes' ]]; then
		push "Audio: hay un dispositivo 'silenciado', solucionando (..)"
		amixer -c 0 set Master playback 100% unmute >/dev/null 2>&1
		sleep 1
		amixer sset Master unmute >/dev/null 2>&1
		amixer sset Speaker unmute >/dev/null 2>&1
		amixer sset Headphone unmute >/dev/null 2>&1

		muted=$(pacmd list-sinks | awk '/muted/ { print $2 }')
		[[ $muted == 'no' ]] && push "Audio: dispositivo de audio pudo ser 'unmuted' -OK"
	else
		push "No hay dispositivo de audio 'muted' -OK" "v"
	fi	

	# aplicar algo de esto?
	# https://askubuntu.com/questions/1029502/no-audio-on-ubuntu-18-04
	# https://help.ubuntu.com/community/SoundTroubleshootingProcedure
	# https://zillowtech.com/ubuntu-no-sound.html
}

# -- OK
performance () {
	local mem_ava=$(cat /proc/meminfo | grep MemAvailable | awk '{print $2}')	

	local free_space_root=$(df -h | awk '
		$6=="/" {
			print $4
		}
	')

	local free_space_root_h=$free_space_root

	free_space_root=${free_space_root/K/000}
	free_space_root=${free_space_root/M/000000}
	free_space_root=${free_space_root/G/000000000}
	free_space_root=${free_space_root/T/000000000000}

	# menos de 4Gb libres en /
	if [[ $free_space_root -le 4000000000 ]]; then 
		free_space_root_h=${free_space_root_h/}
		push "Poco espacio ($free_space_root_h) en partición root"
	else
		push "($free_space_root_h) en partición root" "v"
	fi	
	
	# Menos de 150Kb libres de RAM
	if [[ $mem_ava -le 150000 ]]; then
		push "Memoria disponible insuficiente ($mem_ava kb)"
	else
		push "$mem_ava kb de RAM disponible" "v"
	fi	
}


# Detectar errores de Ethernet
ethernet () 
{
	local hardware=$(lspci -k | grep -i -A2 Ethernet | grep -i 'Subsystem' | cut -d':' -f2 | cut -c2-)
	local driver_en_uso=$(lspci -k | grep -i -A3 Ethernet | grep 'in use:' | cut -d: -f2 | cut -c2-)
	local drivers=$(lspci -k | grep -i -A2 Ethernet | grep -i 'Kernel modules:' | cut -d: -f2 | cut -c2-)

	# No hay driver en uso?
	if [[ -z "$driver_en_uso" ]]; then
		push "Ethernet: no hay driver activo (drivers disponibles: $drivers, device: $hardware)"

		# Verifico que ningún driver esté blacklisted
		for driver in "${drivers[@]}"; do
			in_array "$driver" "${blacklist[@]}"
			[[ $? -eq 0 ]] && push "Ethernet: $driver está en blacklist"
		done
	else 
		push "Driver para $hardware -OK"	
	fi


	interfaces=$(ls /sys/class/net | grep '^e.*')

	local downs=0
	for interface in $interfaces; do
		if [[ -z $(sudo ip address show $interface | grep "UP>") ]]; then
			push "Interfaz $interface está apagada, encendiendo (..)"
			(( downs++ ))
			sudo ip link set "$interface" up 2>/dev/null
			[[ $? -ne 0 ]] && push "Interfaz $interface no se pudo levantar"
		fi
	done	
	
	# Esto también va acá? | LEO: Si, es lo mismo que sea para ethernet que wifi
	if [[ $downs -gt 0 ]]; then
		if [[ ! -z $(systemctl list-unit-files | grep network-manager | grep enabled) ]]; then 
			push "Re-iniciando NetworkManager (..)"
			sudo service network-manager restart
			sleep 10
		fi	
	fi	

	#si tiene conexion al medio (cable) hacer:
	for interface in $interfaces; do
		errora=0
		if [[ $(sudo ip address show $interface | grep "LOWER_UP>") ]]; then
			# Tiene IP
			[[ -z $(ip address show $interface | grep "inet " | awk '{print $2}') ]] && push "No se encontro dirección IP para la interfaz: $interface" && (( errora++ ))

			# IP/CIDR
			maskara=$(ip address show $interface | grep "inet " | awk '{print $2}') # Obtiene IP/CIDR
			maskara=${maskara:(-2)} # Corta el string, dejando los dós digitos de la derecha
			[[ maskara -eq 0 ]] && push "No se encontro mascara de red para la interfaz: $interface" && (( errora++ ))

			# Gateway
			[[ -z $(ip route show |grep default | awk '{print $3}') ]] && push "No se encontro puerta de enlace para la interfaz: $interface"
			gateway=$(ip route show |grep default | awk '{print $3}' | cut -d$'\n' -f1)

			# DNS
			dns=$(cat /etc/resolv.conf | grep nameserver -m 1 | awk '{print $2}')
			[[ -z $dns ]] && push "No se encontraron servidores DNS en '/etc/resolv.conf' "

			# si errora es igual a 0 hace ping contra el router
			if [[ $errora -eq 0 ]]; then
				push "Probando conexion de $interface, espere..."
				
				# Ping Gateway
				myping=$(ping -c3 $gateway | grep "packets transmitted" | awk '{print $4}')
				[[ myping -eq 0 ]] && push "no hay conexion con el router" || push "Conexion exitosa con el router -OK"
				
				# Ping DNS
				myping=$(ping -c5 $dns | grep "packets transmitted" | awk '{print $4}')
				[[ myping -eq 0 ]] && push "No hay conexion con el servidor DNS" || push "Conexion exitosa con el servidor DNS -OK"
			fi

		else
			push "Cable desconectado en interfaz: $interface"
		fi
	done
}

# Detectar errores de wifi
wireless () {

	# PCI
	local hardware=$(lspci -k | grep -i -A2 wireless | grep -i 'Subsystem' | cut -d':' -f2 | cut -c2-)
	local driver_en_uso=$(lspci -k | grep -i -A3 wireless | grep 'in use:' | cut -d: -f2 | cut -c2-)
	local drivers=$(lspci -k | grep -i -A2 wireless | grep -i 'Kernel modules:' | cut -d: -f2 | cut -c2-)

	# No hay driver en uso?
	if [[ -z "$driver_en_uso" ]]; then
		push "Wireless: no hay driver activo (drivers disponibles: $drivers, device: $hardware)"

		# Verifico que ningún driver esté blacklisted
		blacklisted=0
		for driver in "${drivers[@]}"; do
			in_array "$driver" "${blacklist[@]}"
			[[ $? -eq 0 ]] && { blacklisted=1; push "Wireless: $driver está en blacklist"; }
		done	
		[[ $blacklisted -eq 0 ]] && push "No hay drivers en blacklist -OK" "v"
	else 
		push "Driver $driver_en_uso en uso para $hardware -OK" "v"		
	fi

	# USB
	local raw=$((sudo lsusb -v 2>/dev/null) | grep -B22 -i "Wireless Network Card")
	local id_vendor=$(echo "$raw" | grep idVendor | awk '{print $2}' | cut -dx -f2)
	local id_product=$(echo "$raw" | grep idProduct | awk '{print $2}' | cut -dx -f2)

	hardware=$(echo "$raw" | grep iProduct | awk '{print $3}')
	driver_en_uso=$(usb-devices | grep -A5 "Vendor=$id_vendor ProdID=$id_product" | grep -o Driver=[a-z0-9\-]* | cut -d= -f2)

	# No hay driver en uso?
	if [[ ! -z "$hardware" && -z "$driver_en_uso" ]]; then
		push "Wireless USB: no hay driver para $hardware"
	else
		push "Driver $driver_en_uso en uso para $hardware -OK" "v"
	fi

	# bloqueado ? desbloquear
	rf wlan

	# verifico interfaces
	local interfaces=$(cat /proc/net/dev | grep -o w[a-z0-9]*: | cut -d':' -f1)
	local interfaces_up=$(cat /proc/net/wireless | awk '/:/  {print $1}' | cut -d':' -f1)

	[[ "${#interfaces[@]}" -eq 0 ]] && push "No se encontraron interfaces de red wireless"

	local downs=0
	local fails=0
	for interface in $interfaces; do
		in_array $interface "${interfaces_up[@]}"
		if [[ $? -ne 0 ]]; then
			push "Interfaz $interface está apagada, encendiendo (..)"
			(( downs++ ))
			sudo ip link set "$interface" up 2>/dev/null
			[[ $? -ne 0 ]] && { ((fails++)) && push "Interfaz $interface no se pudo levantar"; }
		fi
	done	

	[[ "${#interfaces[@]}" -eq $fails ]] && return

	if [[ $downs -gt 0 ]]; then
		if [[ ! -z $(systemctl list-unit-files | grep network-manager | grep enable ) ]]; then
			push "Re-iniciando NetworkManager (..)"
			sudo service network-manager restart
			sleep 10
		fi	
	fi

	#si tiene conexion al medio (aire) hacer:
	dns_tested=false
	for interface in $interfaces; do
		errora=0
		if [[ $(sudo ip address show $interface | grep "LOWER_UP>") ]]; then
			# Tiene IP
			[[ -z $(ip address show $interface | grep "inet " | awk '{print $2}') ]] && push "No se encontro dirección IP para la interfaz: $interface" && (( errora++ ))

			# IP/CIDR
			maskara=$(ip address show $interface | grep "inet " | awk '{print $2}') # Obtiene IP/CIDR
			maskara=${maskara:(-2)} # Corta el string, dejando los dós digitos de la derecha
			[[ maskara -eq 0 ]] && { push "No se encontro mascara de red para la interfaz: $interface" && (( errora++ )); }

			# Gateway
			[[ -z $(ip route show |grep default | awk '{print $3}') ]] && push "No se encontro puerta de enlace para la interfaz: $interface"
			gateway=$(ip route show |grep default | awk '{print $3}' | cut -d$'\n' -f1) 

			# DNS
			dns=$(cat /etc/resolv.conf | grep nameserver -m 1 | awk '{print $2}')
			[[ -z $dns ]] && push "No se encontraron servidores DNS en '/etc/resolv.conf' "

			# si errora es igual a 0 hace ping contra router y DNS
			if [[ $errora -eq 0 ]]; then
				push "Probando conexion de $interface, espere..."

				# Ping Gateway
				myping=$(ping -c3 $gateway | grep "packets transmitted" | awk '{print $4}')
				[[ $myping -eq 0 ]] && push "No hay conexion con el router" || push "Conexion exitosa con el router -OK"
				
				# Ping DNS
				if [[ $dns_tested == "false" ]]; then	# testeo el DNS Server una sola vez
					myping=$(ping -c5 $dns | grep "packets transmitted" | awk '{print $4}')
					[[ $myping -eq 0 ]] && push "No hay conexion con el servidor DNS" || push "Conexion exitosa con el servidor DNS -OK"
					dns_tested=true
				fi	
			fi

		else
			push "Sin conexión WiFi en: $interface"
		fi
	done
}

#
## Utils
#

options () 
{
	help=$(cat <<-TEXT

	Usage:
	 $(basename $0) [-v] <options>

	Display or solve hardware configuration issues

	Options:
	 -i, --interactive              interactive mode (menu)

	 -a, --all                      run all tests  
	 -b, --bluetooth                bluetooth checking
	 -t, --touchpad                 touchpad checking
	 -w, --wireless                 wifi tests
	 -e, --ethernet                 ethernet tests
	 -p, --performance              check why computer can be running slow
	 -s, --sound                    sound tests 

	 -h, --help                     display this help
	 -V, --version                  display version

	 -v, --verbose                  shows detailed information
TEXT
)

	verbose=

	case "$1" in
	-v|--verbose)
	    verbose=1
	    shift 1
	    ;;
	esac

	sel=$1

	case $sel in
	-V|--version)
	  	echo "$(basename $0) version $ver"
	  	return
		;;
	-h|--help)
		echo -e "$help"
		return
		;;
	-i|--interactive)
		menu
		;;  
	-a|-all)
		echo -e '\n[Performance]'
		performance
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Sound]'
		sound
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Bluetooth]'
		bluetooth
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Touchpad]'
		touchpad
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Ethernet]'
		sudo true
		ethernet
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		
		echo -e '\n[Wireless]'
		wireless
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-p|--performance)
		performance
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;			
	-s|--sound)
		sound
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-b|--bluetooth)
		bluetooth
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-t|--touchpad)
		touchpad
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;		
	-e|--ethernet)
		sudo true
		ethernet
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;
	-w|wireless)
		sudo true
		wireless
		[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
		;;		
	*)
		
		if [[ $# -eq 0 ]]; then
			echo -e "$help"
		else
			echo -e "$(basename $0): unrecognized option '$sel'\nTry '$(basename $0) --help' for more information";
		fi 
		return
		;;
	esac
}

key () {
	echo -e "\nPresiona enter para continuar..."
	read tecla
}

# MENU
menu () {
	while :
	do
		clear
		echo " Escoja una opcion "
		echo "==================="
		echo "1. Verificar problemas de rendimiento"
		echo "2. Verificar touchpad"
		echo "3. Problemas con ethernet"
		echo "4. Problemas con WiFi"
		echo "5. Problemas con bluetooth"
		echo "6. Problemas de sonido"
		echo "7. Salir del programa"
		echo -en "\nSeleccione una opcion [1 - 7] "
		read opcion
		echo
			case $opcion in
			1) 	performance
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			2) 	touchpad
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			3) 	sudo true; ethernet
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			4) 	sudo true; wireless
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			5)	bluetooth
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			6)	sound
				[[ "${#report[@]}" -eq 0 ]] && echo 'OK.'
				key;;
			7) 	exit 0
				key;;
			*) 	echo "'$opcion' es una opcion invalida."
				key;;
			esac
		unset report[@] # Reinicia variable
	done
}

push () {
	if [[ "$2" != "v" ]] || [[ "$2" == "v" && $verbose -eq 1 ]]; then
		report=("${report[@]}" "$1")
		echo "$1"
	fi
}

function in_array() {
  local x

  entry=$1
  shift 1
  array=( "$@" )
  [ -z "${array}" ] && return 1
  [ -z "${entry}" ] && return 1
  
  for x in ${array[@]}; do
    [ "${x}" == "${entry}" ] && return 0
  done
  
  return 1
}

# Sistema de paquetes utilizado, distribución, etc
describe () {	
	if [[ ! -z $(which apt 2>/dev/null) ]]; then
		pkgm='apt'
		else 
			if [[ ! -z $(which dnf 2>/dev/null) ]]; then
				pkgm='dnf'	
			else
				if [[ ! -z $(which pacman 2>/dev/null) ]]; then
					pkgm='pacman'
				else
					if [[ ! -z $(which emerge 2>/dev/null) ]]; then
						pkgm='emerge'	
					fi	
				fi	
			fi	
	fi 	

	distro=`((cat /etc/*-release 2>/dev/null)| egrep '^ID=' | cut -c4-)`
}

# Drivers en lista negra
blacklist () {
	blacklist=$(cat /etc/modprobe.d/*blacklist* 2>/dev/null | egrep '^blacklist ' | cut -d' ' -f2)
}


describe ; [[ -z $pkgm ]] && push "Package management desconocido"
blacklist


options $@ 